use ::std::env;
use ::std::fmt::Write;
use ::std::fs;
use ::std::fs::read_dir;
use ::std::path::PathBuf;
use ::std::process::Command;

use ::regex::Regex;

include!("src/compile/var_uint_build.rs");

fn main() {
    bin_example_tests();
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=dictionary.txt");
    let base_dict_str = fs::read_to_string("./dictionary.txt").unwrap();
    let base_dict_entries = base_dict_str.lines()
        .collect::<Vec<_>>();
    let code = generate_base_dict_code(&base_dict_entries);
    write_dict_code(&code);
}

fn find_all_bins() -> Vec<String> {
    // trigger error message to list all binaries
    let out = Command::new("cargo")
        .args(["run", "--bin"])
        .output()
        .expect("failed to execute process");
    String::from_utf8(out.stderr)
        .expect("cargo output not utf8")
        .lines()
        .skip(2)
        .map(|line| {
            line.trim().to_owned()
        })
        .filter(|bin| !bin.is_empty())
        .filter(|bin| !bin.contains("debug"))
        .collect()
}

fn find_all_examples() -> Vec<String> {
    let re = Regex::new("^(?:.*/)?([^/]*).rs").unwrap();
    let mut examples = Vec::new();
    for example_res in read_dir("./examples").expect("no example directory") {
        let path_os = example_res.unwrap().file_name();
        let path = path_os.to_str().unwrap();
        if let Some(caps) = re.captures(path) {
            let name = caps.get(1).unwrap().as_str().to_owned();
            examples.push(name);
        }
    }
    examples
}

fn bin_example_tests() {
    println!("cargo:rerun-if-changed=examples");
    let mut code = String::new();
    writeln!(code, "\n// auto-generated by build.rs").unwrap();
    writeln!(code, "#[cfg(test)]").unwrap();
    writeln!(code, "mod generated_tests {{").unwrap();
    for bin in find_all_bins() {
        writeln!(code, "\n\t#[test]").unwrap();
        writeln!(code, "\tfn bin_{bin}_help() {{").unwrap();
        writeln!(code, "\t\tpanic!();").unwrap();
        writeln!(code, "\t}}").unwrap();
    }
    for example in find_all_examples() {
        writeln!(code, "\n\t#[test]").unwrap();
        writeln!(code, "\tfn example_{example}() {{").unwrap();
        writeln!(code, "\t\tpanic!();").unwrap();
        writeln!(code, "\t}}").unwrap();
    }
    writeln!(code, "}}").unwrap();
    let mut out_file = PathBuf::from(env::var("OUT_DIR").unwrap());
    out_file.push("generated_tests.rs");
    fs::write(out_file, code).expect("failed to write");
}

fn generate_base_dict_code(base_dict_entries: &[&str]) -> String {
    let mut init_buffer = String::with_capacity(base_dict_entries.len() * 16);
    let mut cost_buffer = String::new();
    writeln!(init_buffer, "pub const DICT: [DictEntry; {}] = [", base_dict_entries.len()).unwrap();
    for (pos, entry) in base_dict_entries.iter().enumerate() {
        let cost = encode_snippet_len_estimate(pos.try_into().unwrap());
        let creator = match *entry {
            "$magic-backspace$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::Backspace => {cost},").unwrap();
                "DictEntry::Backspace".to_owned()
            },
            "$magic-backspace-front$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::BackspaceFront => {cost},").unwrap();
                "DictEntry::BackspaceFront".to_owned()
            },
            "$magic-newline$" => format!("s(\"\\n\",{cost})"),
            "$magic-capitalize-first$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::CapitalizeFirst => {cost},").unwrap();
                "DictEntry::CapitalizeFirst".to_owned()
            },
            "$magic-capitalize-all$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::CapitalizeAll => {cost},").unwrap();
                "DictEntry::CapitalizeAll".to_owned()
            },
            "$magic-reverse$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::Reverse => {cost},").unwrap();
                "DictEntry::Reverse".to_owned()
            },
            "$magic-unicode$" => {
                writeln!(cost_buffer, "\t\t\tDictEntry::UnicodeLookup => {cost},").unwrap();
                "DictEntry::UnicodeLookup".to_owned()
            },
            "\"" => format!("s(\"\\\"\",{cost})"),
            _ => if entry.ends_with("$magic-capitalize-next$") {
                format!("S(\"{}\",{cost})", entry.strip_suffix("$magic-capitalize-next$").unwrap())
            } else {
                assert!(!entry.contains("$magic"), "unknown: '{entry}'");
                format!("s(\"{entry}\",{cost})")
            },
        };
        writeln!(init_buffer, "\t{creator},").unwrap();
    }
    write!(init_buffer, "];\n\n").unwrap();
    writeln!(init_buffer, "impl DictEntry {{\n\tpub fn cost(&self) -> Cost {{\n\t\tmatch self {{\n\t\t\tDictEntry::Snippet {{ cost, .. }} => *cost,\n{cost_buffer}\t\t}}\n\t}}\n}}\n").unwrap();
    init_buffer
}

fn write_dict_code(code: &str) {
    let mut out_file = PathBuf::from(env::var("OUT_DIR").unwrap());
    out_file.push("dict_init.rs");
    fs::write(out_file, code).expect("failed to write");
}
