use ::std::cmp::Ordering;
use ::std::fmt::Write;
use ::std::hash;
use ::std::hash::Hasher;

use ::tinyvec::ArrayVec;
use ::tinyvec_string::ArrayString;

use crate::dict::{Cost, CowDictStr, DictIx, DictStr, DictStrContent, LONGEST_DICT_ENTRY_BYTES, MAX_TEXT_TRANSFORMS};
use crate::tilde_log;

pub type OpIndices = ArrayVec<[DictIx; MAX_TEXT_TRANSFORMS]>;

pub const UNICODE_MAGIC_INDX: DictIx = 70;
//TODO @mark: move all derived data to one module, or generate from build.rs
type Chars = ArrayVec<[char; LONGEST_DICT_ENTRY_BYTES]>;

#[derive(Debug, Default, Clone, PartialEq, Eq)]
pub struct TextTransformation {
    pub case_first: bool,
    pub case_all: bool,
    pub reverse: bool,
    pub pop_start: u8,
    pub pop_end: u8,
}

#[derive(Debug)]
pub enum SnipOrChar {
    Snip(&'static str),
    Char(char),
}

impl TextTransformation {
    pub fn new_noop() -> TextTransformation {
        TextTransformation {
            case_first: false,
            case_all: false,
            reverse: false,
            pop_start: 0,
            pop_end: 0,
        }
    }

    pub fn apply(&self, input: SnipOrChar) -> CowDictStr {
        if self != &Self::new_noop() {  // should get optimized away in release mode
            tilde_log!("transform: case_first={} case_all={} reverse={} pop_start={} pop_end={}",
                self.case_first, self.case_all, self.reverse, self.pop_start, self.pop_end);
        }
        match input {
            SnipOrChar::Snip(text) => self.apply_str(text),
            SnipOrChar::Char(letter) => CowDictStr::Owned(self.apply_char(letter)
                .map_or_else(DictStr::empty, DictStr::from_char)),
        }
    }

    fn apply_char(&self, input: char) -> Option<char> {
        if self.pop_start > 0 || self.pop_end > 0 {
            return None;
        }
        let mut letter = input;
        if self.case_all || self.case_first {
            switch_capitalization_char(&mut letter);
        }
        Some(letter)
    }

    pub fn apply_str(&self, input: &'static str) -> CowDictStr {
        if self == &Self::new_noop() || input.is_empty() {
            return CowDictStr::Borrowed(input);
        }
        if input.len() <= self.pop_start as usize + self.pop_end as usize {
            return CowDictStr::Borrowed("");
        }
        let mut chars: Chars = input.chars().collect();
        debug_assert!(!chars.is_empty());
        let need_alloc = self.case_all || self.case_first || self.reverse;
        if need_alloc {
            CowDictStr::Owned(self.apply_all_alloc(input, chars))
        } else {
            CowDictStr::Borrowed(self.apply_pop_noalloc(input, chars))
        }
    }

    fn apply_pop_noalloc(&self, input: &'static str, mut chars: Chars) -> &'static str {
        debug_assert!(!self.reverse);
        debug_assert!(!self.case_all);
        debug_assert!(!self.case_first);
        let chars_last_ix = chars.len() - 1;
        let mut start_index = 0;
        for chr in &chars[0..self.pop_start as usize] {
            start_index += chr.len_utf8();
        }
        let mut end_index = 0;
        for i in 0..self.pop_end as usize {
            end_index += match chars.get(chars_last_ix - i) {
                Some(c) => c.len_utf8(),
                None => break,
            }
        }
        &input[start_index..input.len()-end_index]
    }

    fn apply_all_alloc(&self, input: &'static str, mut chars: Chars) -> DictStr {
        debug_assert!(self.reverse || self.case_all || self.case_first);
        if self.reverse {
            chars.reverse();
        }
        for _ in 0..self.pop_end {
            chars.pop();
        }
        if self.pop_start > 0 {
            chars = chars.into_iter().skip(self.pop_start as usize).collect();
        }
        if self.case_all {
            if self.case_first {
                chars.iter_mut().skip(1).for_each(switch_capitalization_char);
            } else {
                chars.iter_mut().for_each(switch_capitalization_char);
            }
        } else if self.case_first {
            switch_capitalization_char(&mut chars[0])
        }
        chars.into_iter()
            .collect::<DictStrContent>()
            .into()
    }

    pub fn operation_indices(&self) -> OpIndices {
        let mut indices = OpIndices::new();
        if self.case_first {
            indices.push(71);
        }
        if self.case_all {
            indices.push(72);
        }
        if self.reverse {
            indices.push(304);
        }
        for _ in 0..self.pop_start {
            indices.push(303);
        }
        for _ in 0..self.pop_end {
            indices.push(0);
        }
        indices
    }

    pub fn cost(&self) -> Cost {
        // update constants here to match those generated by build.rs
        self.pop_start * 3 + self.pop_end +
            self.case_all as u8 * 3 + self.case_first as u8 * 3 +
            self.reverse as u8 * 3
    }

    pub fn name(&self) -> ArrayString<[u8; 6]> {
        let mut repr = ArrayString::new();
        write!(repr, "{}", match (self.case_all, self.case_first) {
                (true, false) => 'a',
                (false, true) => 'f',
                (true, true) => 'w',
                (false, false) => 'n',
        }).unwrap();
        write!(repr, "{}", if self.reverse { 'r' } else { 'i' }).unwrap();
        if self.pop_start >= 10 || self.pop_end >= 10 {
            write!(repr, "{}_{}", self.pop_start, self.pop_end).unwrap();
        } else {
            write!(repr, "{}{}", self.pop_start, self.pop_end).unwrap();
        }
        repr
    }
}

#[allow(dead_code)]
fn switch_capitalization_char(orig_first: &mut char) {
    //TODO @mark: move this functions? add tests
    let mut upper = orig_first.to_uppercase();
    if let Some(switch_first) = upper.next() {
        if switch_first != *orig_first {
            assert!(upper.nth(1).is_none(), "multi-char uppercase representations not yet supported"); //TODO @mark
            *orig_first = switch_first;
            return;
        }
    };
    let mut lower = orig_first.to_lowercase();
    if let Some(switch_first) = lower.next() {
        if switch_first != *orig_first {
            assert!(lower.nth(1).is_none(), "multi-char lowercase representations not yet supported"); //TODO @mark
            *orig_first = switch_first;
        }
    }
}

#[cfg(test)]
mod capitalisation {
    use super::*;

    #[test]
    fn to_upper() {
        let mut letter = 'a';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, 'A');
        let mut letter = 'Ã©';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, 'Ã‰');
    }

    #[test]
    fn to_lower() {
        let mut letter = 'A';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, 'a');
        let mut letter = 'Ã‰';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, 'Ã©');
    }

    #[test]
    fn no_case() {
        let mut letter = '.';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, '.');
        let mut letter = 'ðŸ¦€';
        switch_capitalization_char(&mut letter);
        assert_eq!(letter, 'ðŸ¦€');
    }
}

#[cfg(test)]
mod transform {
    use super::*;

    #[test]
    fn capitalize_first_and_all() {
        let tt = TextTransformation {
            case_first: true,
            case_all: true,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("abc");
        assert_eq!(res.as_ref(), "aBC")
    }

    #[test]
    fn capitalize_all_reverse() {
        let tt = TextTransformation {
            reverse: true,
            case_all: true,
            pop_start: 1,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("abcdef");
        assert_eq!(res.as_ref(), "EDCBA")
    }

    #[test]
    fn capitalize_pop() {
        let tt = TextTransformation {
            case_first: true,
            pop_start: 2,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("abcd");
        assert_eq!(res.as_ref(), "Cd")
    }

    #[test]
    fn reverse_pop() {
        let tt = TextTransformation {
            reverse: true,
            pop_end: 1,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("abc");
        assert_eq!(res.as_ref(), "cb")
    }

    #[test]
    fn pop_partial() {
        let tt = TextTransformation {
            pop_start: 2,
            pop_end: 2,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("helloä½ å¥½!");
        assert_eq!(res, CowDictStr::Borrowed("lloä½ "))
    }

    #[test]
    fn pop_all() {
        let tt = TextTransformation {
            pop_start: 2,
            pop_end: 1,
            ..TextTransformation::default()
        };
        let res = tt.apply_str("a");
        assert_eq!(res, CowDictStr::Borrowed(""));
        let res = tt.apply_str("ä½ å¥½!");
        assert_eq!(res, CowDictStr::Borrowed(""))
    }
}

#[cfg(test)]
mod indices_in_sync_with_dict {
    use ::std::cell::LazyCell;
    use ::std::collections::HashMap;

    use ::strum::IntoEnumIterator;

    use crate::dict::DICT;
    use crate::dict::DictEntry;

    use super::*;

    thread_local! {
        static DICT_POSITIONS: LazyCell<HashMap<DictEntry, usize>> = LazyCell::new(||
            DICT.iter().enumerate()
                .map(|(index, entry)| (*entry, index))
                .collect());
    }

    fn assert_transformation_index(trans: TextTransformation, entry: DictEntry) {
        let indices = trans.operation_indices();
        assert!(indices.len() == 1);
        let index: usize = indices[0]
            .try_into()
            .expect("could not convert index to usize");
        let expected = DICT_POSITIONS.with(|dict_pos| {
            *dict_pos
                .get(&entry)
                .unwrap()
        });
        assert_eq!(index, expected, "index should be {expected} but is {index}");
    }

    #[test]
    fn case_first() {
        assert_transformation_index(
            TextTransformation { case_first: true, ..Default::default() },
            DictEntry::CapitalizeFirst)
    }

    #[test]
    fn case_all() {
        assert_transformation_index(
            TextTransformation { case_all: true, ..Default::default() },
            DictEntry::CapitalizeAll)
    }

    #[test]
    fn pop_end() {
        assert_transformation_index(
            TextTransformation { pop_end: 1, ..Default::default() },
            DictEntry::Backspace)
    }

    #[test]
    fn pop_start() {
        assert_transformation_index(
            TextTransformation { pop_start: 1, ..Default::default() },
            DictEntry::BackspaceFront)
    }

    #[test]
    fn reverse() {
        assert_transformation_index(
            TextTransformation { reverse: true, ..Default::default() },
            DictEntry::Reverse)
    }

    #[test]
    fn unicode_lookup() {
        let entry = DictEntry::UnicodeLookup;
        let index: usize = UNICODE_MAGIC_INDX
            .try_into()
            .expect("could not convert index to usize");
        let expected = DICT_POSITIONS.with(|dict_pos| {
            *dict_pos
                .get(&entry)
                .unwrap()
        });
        assert_eq!(index, expected, "index should be {expected} but is {index}");
    }
}

#[cfg(test)]
mod cost {
    use crate::compile::{Closer, encode_uint_vec};
    use crate::dict::all_transformations;
    use crate::dict::DICT;

    use super::*;

    #[test]
    fn operation_cost_in_sync_with_transform_cost() {
        for tt in all_transformations() {
            let token_cost = tt.operation_indices().into_iter()
                .map(|ix| DICT.get(ix as usize).unwrap().cost())
                .sum();
            assert_eq!(tt.cost(), token_cost, "wrong cost for {tt:?}");
        }
    }

    #[test]
    fn compressed_length_matches_cost() {
        let mut ops: Vec<DictIx> = Vec::new();
        for tt in all_transformations() {
            ops.clear();
            for op in tt.operation_indices() {
                ops.push(op);
            }
            let enc = encode_uint_vec(&ops, Closer::Text);
            assert_eq!(enc.len() - 1, tt.cost() as usize,
                "encoding {:?} ops {:?} to {:?} which has length {} but cost {}",
                tt, ops, enc, enc.len(), tt.cost());
        }
    }
}
